const functions = require('firebase-functions');
const admin = require('firebase-admin');

// Initialize admin if not already done
if (!admin.apps.length) {
  admin.initializeApp();
}

const db = admin.firestore();

// ============================================
// ðŸ“¤ MAIN FUNCTION: Send Push on New Notification
// ============================================

exports.sendPushNotification = functions.firestore
  .document('notifications/{notificationId}')
  .onCreate(async (snap, context) => {
    const notification = snap.data();
    const notificationId = context.params.notificationId;

    console.log('ðŸ”” New notification created:', notificationId, notification.type);

    try {
      // Get the target user's FCM tokens
      const userDoc = await db.collection('users').doc(notification.userId).get();
      
      if (!userDoc.exists) {
        console.log('ðŸ”” User not found:', notification.userId);
        return null;
      }

      const userData = userDoc.data();
      const fcmTokens = userData.fcmTokens || [];

      if (fcmTokens.length === 0) {
        console.log('ðŸ”” No FCM tokens for user:', notification.userId);
        return null;
      }

      // Build the push notification payload
      const payload = buildNotificationPayload(notification);
      
      console.log('ðŸ”” Sending to', fcmTokens.length, 'device(s)');

      // Send to all user's devices
      const response = await admin.messaging().sendEachForMulticast({
        tokens: fcmTokens,
        notification: {
          title: payload.title,
          body: payload.body
        },
        data: {
          type: notification.type || 'general',
          notificationId: notificationId,
          ...payload.data
        },
        apns: {
          headers: {
            'apns-priority': '10'
          },
          payload: {
            aps: {
              alert: {
                title: payload.title,
                body: payload.body
              },
              badge: payload.badge || 1,
              sound: 'default',
              'mutable-content': 1
            }
          }
        },
        android: {
          priority: 'high',
          notification: {
            icon: 'ic_notification',
            color: '#ec4899',
            channelId: 'datemaker_default'
          }
        }
      });

      console.log('ðŸ”” Push sent! Success:', response.successCount, 'Failed:', response.failureCount);

      // Clean up invalid tokens
      if (response.failureCount > 0) {
        const tokensToRemove = [];
        response.responses.forEach((resp, idx) => {
          if (!resp.success) {
            const error = resp.error;
            if (error.code === 'messaging/invalid-registration-token' ||
                error.code === 'messaging/registration-token-not-registered') {
              tokensToRemove.push(fcmTokens[idx]);
            }
          }
        });

        if (tokensToRemove.length > 0) {
          console.log('ðŸ”” Removing', tokensToRemove.length, 'invalid token(s)');
          await db.collection('users').doc(notification.userId).update({
            fcmTokens: admin.firestore.FieldValue.arrayRemove(...tokensToRemove)
          });
        }
      }

      // Update notification with sent status
      await snap.ref.update({
        pushSent: true,
        pushSentAt: admin.firestore.FieldValue.serverTimestamp()
      });

      return { success: true, sent: response.successCount };

    } catch (error) {
      console.error('ðŸ”” Error sending push:', error);
      
      // Mark as failed
      await snap.ref.update({
        pushSent: false,
        pushError: error.message
      });
      
      return { success: false, error: error.message };
    }
  });

// ============================================
// ðŸ› ï¸ BUILD NOTIFICATION PAYLOAD
// ============================================

function buildNotificationPayload(notification) {
  const type = notification.type;
  
  // Default payload
  let payload = {
    title: 'DateMaker',
    body: notification.message || 'You have a new notification',
    data: {},
    badge: 1
  };

  switch (type) {
    // Social notifications
    case 'friend_request':
      payload.title = 'New Friend Request ðŸ‘‹';
      payload.body = notification.message;
      payload.data = { action: 'open_friends', fromUserId: notification.fromUserId };
      break;

    case 'friend_accepted':
      payload.title = 'Friend Request Accepted ðŸŽ‰';
      payload.body = notification.message;
      payload.data = { action: 'open_friends', fromUserId: notification.fromUserId };
      break;

    case 'new_message':
      payload.title = `${notification.fromUserName || 'Someone'} ðŸ’¬`;
      payload.body = notification.preview || 'Sent you a message';
      payload.data = { 
        action: 'open_chat', 
        conversationId: notification.conversationId,
        fromUserId: notification.fromUserId 
      };
      break;

    case 'date_invite':
      payload.title = 'Date Invitation ðŸ“…';
      payload.body = notification.message;
      payload.data = { action: 'open_invite', dateId: notification.dateId };
      break;

    case 'surprise_date':
      payload.title = 'Surprise! ðŸŽ';
      payload.body = notification.message;
      payload.data = { action: 'open_surprise', dateId: notification.dateId };
      break;

    case 'date_liked':
      payload.title = 'Someone loved your date â¤ï¸';
      payload.body = notification.message;
      payload.data = { action: 'open_date', dateId: notification.dateId };
      break;

    case 'date_comment':
      payload.title = 'New comment ðŸ’¬';
      payload.body = notification.message;
      payload.data = { action: 'open_date', dateId: notification.dateId };
      break;

    // Gamification notifications
    case 'achievement':
      payload.title = 'Achievement Unlocked! ðŸ†';
      payload.body = `${notification.achievementTitle} +${notification.xpEarned} XP`;
      payload.data = { action: 'open_achievements' };
      break;

    case 'level_up':
      payload.title = 'Level Up! â¬†ï¸';
      payload.body = `You reached Level ${notification.newLevel}!`;
      payload.data = { action: 'open_profile' };
      break;

    case 'streak':
    case 'streak_milestone':
      payload.title = 'Streak Milestone! ðŸ”¥';
      payload.body = notification.message;
      payload.data = { action: 'open_profile' };
      break;

    case 'streak_at_risk':
      payload.title = 'Streak at Risk! âš ï¸';
      payload.body = notification.message;
      payload.data = { action: 'open_generator' };
      break;

    case 'challenge_complete':
      payload.title = 'Challenge Complete! ðŸŽ¯';
      payload.body = notification.message;
      payload.data = { action: 'open_challenges' };
      break;

    case 'mystery_bonus':
      payload.title = 'Mystery Bonus Day! ðŸŽ°';
      payload.body = notification.message;
      payload.data = { action: 'open_challenges' };
      break;

    case 'monthly_recap':
      payload.title = 'Your Monthly Recap is Ready! ðŸ“Š';
      payload.body = notification.message;
      payload.data = { action: 'open_recap' };
      break;

    case 'weekly_summary':
      payload.title = 'Weekly Summary ðŸ“…';
      payload.body = notification.message;
      payload.data = { action: 'open_profile' };
      break;

    default:
      // Use provided message
      payload.body = notification.message || 'You have a new notification';
      break;
  }

  return payload;
}

// ============================================
// ðŸ• SCHEDULED: DAILY ENGAGEMENT REMINDERS
// ============================================

// Morning inspiration - 9 AM local (adjust timezone as needed)
exports.scheduledMorningNotification = functions.pubsub
  .schedule('0 9 * * *')
  .timeZone('America/Los_Angeles') // Change to your users' timezone
  .onRun(async (context) => {
    console.log('ðŸŒ… Running morning notification job');
    
    const messages = [
      { title: "Good morning! â˜€ï¸", body: "Ready to plan something special for today?" },
      { title: "Rise and shine! ðŸ’•", body: "What kind of date are you in the mood for?" },
      { title: "Date night starts now! ðŸ“…", body: "Tap to discover today's perfect date idea" }
    ];
    
    const message = messages[Math.floor(Math.random() * messages.length)];
    
    // Get users with notifications enabled (you'd need a field for this)
    // For now, we'll skip this and let local notifications handle it
    console.log('ðŸŒ… Morning notification would send:', message);
    
    return null;
  });

// Tonight's vibe - 5 PM
exports.scheduledEveningNotification = functions.pubsub
  .schedule('0 17 * * *')
  .timeZone('America/Los_Angeles')
  .onRun(async (context) => {
    console.log('ðŸŒ† Running evening notification job');
    
    const vibes = [
      { title: "Tonight's Vibe: Cozy Dinner ðŸ", body: "One tap to generate the perfect evening â†’" },
      { title: "Tonight's Vibe: Adventure Mode ðŸŽ¯", body: "Something exciting is waiting!" },
      { title: "Tonight's Vibe: Spontaneous! âš¡", body: "Let fate decide your evening" }
    ];
    
    const vibe = vibes[Math.floor(Math.random() * vibes.length)];
    console.log('ðŸŒ† Evening notification would send:', vibe);
    
    return null;
  });

// ============================================
// ðŸ”¥ STREAK CHECK - Daily at 8 PM
// ============================================

exports.checkStreaksAtRisk = functions.pubsub
  .schedule('0 20 * * *')
  .timeZone('America/Los_Angeles')
  .onRun(async (context) => {
    console.log('ðŸ”¥ Checking streaks at risk');
    
    try {
      // Get all users with active streaks
      const usersSnapshot = await db.collection('dateStreaks')
        .where('currentStreak', '>', 0)
        .get();
      
      const now = new Date();
      const warnings = [];
      
      for (const doc of usersSnapshot.docs) {
        const streak = doc.data();
        const lastDate = streak.lastDateAt?.toDate() || new Date(0);
        const daysSinceLastDate = Math.floor((now - lastDate) / (1000 * 60 * 60 * 24));
        
        // Warn if 5+ days since last date (streak at risk)
        if (daysSinceLastDate >= 5 && daysSinceLastDate < 7) {
          const daysRemaining = 7 - daysSinceLastDate;
          
          // Create notification
          await db.collection('notifications').add({
            userId: doc.id,
            type: 'streak_at_risk',
            streakWeeks: streak.currentStreak,
            daysRemaining: daysRemaining,
            message: `Your ${streak.currentStreak}-week streak is at risk! ${daysRemaining} days left.`,
            emoji: 'âš ï¸',
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            read: false
          });
          
          warnings.push(doc.id);
        }
      }
      
      console.log('ðŸ”¥ Sent streak warnings to', warnings.length, 'users');
      return { warned: warnings.length };
      
    } catch (error) {
      console.error('ðŸ”¥ Error checking streaks:', error);
      return { error: error.message };
    }
  });

// ============================================
// ðŸ“Š MONTHLY RECAP - 1st of each month
// ============================================

exports.sendMonthlyRecapReminder = functions.pubsub
  .schedule('0 10 1 * *') // 10 AM on the 1st
  .timeZone('America/Los_Angeles')
  .onRun(async (context) => {
    console.log('ðŸ“Š Sending monthly recap reminders');
    
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                        'July', 'August', 'September', 'October', 'November', 'December'];
    
    const lastMonth = new Date();
    lastMonth.setMonth(lastMonth.getMonth() - 1);
    const monthName = monthNames[lastMonth.getMonth()];
    
    try {
      // Get premium users (you'd need to track this)
      // For now, get all users who had dates last month
      const startOfLastMonth = new Date(lastMonth.getFullYear(), lastMonth.getMonth(), 1);
      const endOfLastMonth = new Date(lastMonth.getFullYear(), lastMonth.getMonth() + 1, 0);
      
      const memoriesSnapshot = await db.collection('dateMemories')
        .where('createdAt', '>=', startOfLastMonth)
        .where('createdAt', '<=', endOfLastMonth)
        .get();
      
      // Get unique users
      const userIds = new Set();
      memoriesSnapshot.docs.forEach(doc => {
        userIds.add(doc.data().userId);
      });
      
      // Send recap notification to each
      for (const userId of userIds) {
        await db.collection('notifications').add({
          userId: userId,
          type: 'monthly_recap',
          monthName: monthName,
          message: `Your ${monthName} recap is ready! See your date highlights.`,
          emoji: 'ðŸ“Š',
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
          read: false
        });
      }
      
      console.log('ðŸ“Š Sent recap reminders to', userIds.size, 'users');
      return { sent: userIds.size };
      
    } catch (error) {
      console.error('ðŸ“Š Error sending recap reminders:', error);
      return { error: error.message };
    }
  });